title=Ma participation à CodeStory en java : Intro
date=2013-02-03
type=post
tags=CodeStory,Java,TDD
status=published
id=ma-participation-codestory-en-java-intro
~~~~~~
<p>La première étape du concours <a href="http://www.code-story.net/">Code Story</a> vient de se terminer, je vais donc tenter de faire un résumé de ma participation à ce concours. Pour les curieux, le classement est disponible <a href="https://www.blogger.com/status.code-story.net">ici</a>.<br />Etant sans doute un peu malade, j'ai participé à ce concours 3 fois : en Java, en Ceylon et en Scala. Mon inscription principale avec le code le plus soigné et complet reste celle en Java. Je vais donc dans un premier temps vous faire un retour sur la partie Java. L'ensemble du code source de ma participation en java est disponible sur <a href="https://github.com/ybonnel/CodeStory">github</a><br />Les étapes de l'application étant nombreuses, je vais découper ça en plusieurs articles  : <ul><li>Serveur Http et TDD (déjà présenté dans l'article suivant : <a href="http://www.ybonnel.fr/2013/01/marre-du-cloud-et-du-jee-vive-lauto.html">Marre du cloud et du JEE -&gt; vive l'auto-hébergement et les main.</a>)</li><li>Les logs et répondre à des questions fixes (dans le présent article)</li><li><a href="http://www.ybonnel.fr/2013/02/codestory-en-java-scalaskel-et-la.html">Scalaskel et la calculette</a></li><li><a href="http://www.ybonnel.fr/2013/02/code-story-en-java-jajascript-et-les.html">Jajascript et les performances</a></li></ul></p> <h1>Principes du concours</h1><p>Afin de comprendre les choix que j'ai faits au niveau du code, il est important de connaître les principes de ce concours. Au départ, on s'inscrit en donnant juste une URL publique (ex : http://serveur.mondomain.fr:8080). Le seul truc que l'on sait avant de commencer, c'est qu'on va recevoir une requête GET sur http://serveur.mondomain.fr:8080/?q=Quelle+est+ton+adresse+email à laquelle il faut répondre avec l'adresse email, pour les curieux, le règlement est disponible <a href="http://code-story.net/2013/01/04/concours-2013.html">ici</a>. On se doute également dès le départ qu'on recevra d'autres requêtes HTTP auxquelles il faudra répondre (d'où le besoin de logs).</p><br/> <h1>Répondre à des questions fixes</h1><p>Les premières requêtes n'étaient pas très compliquées, il s'agissait simplement de questions avec une réponse fixe attendue. Pour information, voici la liste des questions reçues : <ul><li>?q=Quelle est ton adresse email</li><li>?q=Es tu abonne a la mailing list(OUI/NON)</li><li>?q=Es tu heureux de participer(OUI/NON)</li><li>?q=Es tu pret a recevoir une enonce au format markdown par http post(OUI/NON)</li><li>?q=Est ce que tu reponds toujours oui(OUI/NON)</li><li>?q=As tu bien recu le premier enonce(OUI/NON)</li><li>?q=As tu bien recu le second enonce(OUI/NON)</li><li>?q=As tu passe une bonne nuit malgre les bugs de l etape precedente(PAS_TOP/BOF/QUELS_BUGS)</li><li>?q=As tu copie le code de ndeloof(OUI/NON/JE_SUIS_NICOLAS)</li><li>?q=Souhaites-tu-participer-a-la-suite-de-Code-Story(OUI/NON)</li></ul>Afin de pouvoir rapidement faire évoluer l'application pour ajouter la gestion de futures questions, voici comment j'ai développé.</p><p>Première étape le test JUnit (et oui j'ai fait du TDD), voici donc l'exemple du test pour la troisième question : <pre class="brush:java">@Test<br />public void should_answer_to_participate() throws Exception {<br />    WebConversation wc = new WebConversation();<br />    WebResponse response = wc.getResponse(getURL() + "/?q=Es tu heureux de participer(OUI/NON)");<br />    assertEquals(200, response.getResponseCode());<br />    assertEquals("Response must be 'OUI'", "OUI", response.getText());<br />}<br /></pre>Le test est donc très simple, rapide à écrire, et se met à la place du robot pour effectuer le test (la librairie utilisée est HttpUnit).</p><p>Voyons maintenant comment j'ai codé le serveur. A travers les premières questions, on se rend compte qu'une partie des requêtes reçues va l'être avec le paramètre "q", j'ai donc décidé de créer la notion de QueryHandler chargée de répondre aux requêtes reçues avec ce paramètre. Voici la classe abstraite associée : <pre class="brush:java">public abstract class AbstractQueryHandler {<br />    public abstract String getResponse(String query);<br />}<br /></pre></p><p>La tuyauterie pour appeler le handler (et le bon) et relativement simple. Côté handler HTTP, c'est juste la récupération du paramètre et l'appel d'une méthode de la classe chargée d'appeler le bon QueryHandler : <pre class="brush:java">String query = request.getParameter(QUERY_PARAMETER);<br />if (query != null) {<br />    response = QueryType.getResponse(query);<br />}<br /></pre>La variable "response" contient le texte à renvoyer, mais également le status HTTP à utiliser. La classe "QueryType" est en fait un "enum", prenant en paramètre de constructeur le handler à utiliser, et ayant une méthode abstraite "isThisQueryType" prenant en paramètre la "query" et renvoyant un boolean permettant de savoir si c'est lui qui est responsable de cette "query". Et pour finir, cet enum contient une méthode statique chargée d'appeler le bon QueryHandler en fonction de la query. Voici la classe avec l'exemple de question vu plus haut : <pre class="brush:java">import fr.ybonnel.codestory.WebServerResponse;<br />import javax.servlet.http.HttpServletResponse;<br /><br />public enum QueryType {<br /><br />    PARTICIAPATE(new FixResponseQueryHandler("OUI")) {<br />        @Override protected boolean isThisQueryType(String query) {<br />            return query.equals("Es tu heureux de participer(OUI/NON)");<br />        }<br />    };<br /><br />    private AbstractQueryHandler queryHandler;<br /><br />    QueryType(AbstractQueryHandler queryHandler) {<br />        this.queryHandler = queryHandler;<br />    }<br /><br />    protected abstract boolean isThisQueryType(String query);<br /><br />    public static WebServerResponse getResponse(String query) {<br />        for (QueryType oneQuestion : values()) {<br />            if (oneQuestion.isThisQueryType(query)) {<br />                return new WebServerResponse(HttpServletResponse.SC_OK, oneQuestion.queryHandler.getResponse(query));<br />            }<br />        }<br />        return new WebServerResponse(HttpServletResponse.SC_NOT_FOUND, "Query " + query + " is unknown");<br />    }<br />}<br /></pre>Vous pouvez donc voir dans cette enum l'apparition de la classe FixResponseQueryHandler, cette classe est très simple, son rôle est simplement de renvoyer une réponse fixe, la voici : <pre class="brush:java">public class FixResponseQueryHandler extends AbstractQueryHandler {<br /><br />    private String response;<br />    public FixResponseQueryHandler(String response) {<br />        this.response = response;<br />    }<br /><br />    @Override public String getResponse(String query) {<br />        return response;<br />    }<br />}<br /></pre></p><p>Voici donc tous les éléments que j'ai mis en place pour les questions avec réponses fixes. A posteriori, on aurait pu mettre en place une simple Map (c'est ce que j'ai fait en Ceylon et en Scala), mais c'est le problème de coder au fur et à mesure que les questions arrivent, on ne sait pas trop ce qui va arriver ensuite... J'aurais évidement pu refactorer tout ça (les tests unitaires me permettant d'être sûr de ne pas tout casser), mais j'ai eu la flemme, d'autant que ce n'est pas la partie la plus intéressante, les énoncés suivants étant bien plus sympas. </p><br/> <h1>Les logs</h1><p>Un élément important de ce concours, c'est que nous ne recevions aucune consigne par mail, twitter ou pigeon voyageur. Le seul mode d'interaction était l'envoi d'une requête HTTP par le robot qui renvoyait la requête tant qu'on ne répondait pas correctement. Afin de pouvoir être réactif aux nouvelles requêtes en toute circonstance, je me suis ajouté un système de logs en base de donnée avec possibilité de les récupérer par un appel http (ce qui me permettait de la faire même depuis mon téléphone). Je ne vais pas vous détailler comment j'ai mis en place ce système, mais plutôt comment j'ai mis en place la BDD tout en gardant un système simple et rapide à tester. </p> <h2>Mise en place de la BDD</h2><p>Comme vous le savez, je n'ai pas de stack compliquée pour cette application, pour mettre en place une BDD simple, je suis parti sur un h2 embarqué. Première étape ajout de la dépendance au pom.xml : <pre class="bursh:xml"><br />&lt;dependency&gt;<br />    &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br />    &lt;artifactId&gt;h2&lt;/artifactId&gt;<br />    &lt;version&gt;1.3.170&lt;/version&gt;<br />&lt;/dependency&gt;<br /></pre></p><p>Sur l'utilisation de celle-ci, rien d'extra-ordinaire, je suis parti sur du jdbc à la main. Ça peux paraître archaïque, mais pour gérer 2 pauvres tables (une pour les logs et une pour les énoncés), pas besoin de sortir l'artillerie lourde. Pour les curieux, voici la classe centrale pour gérer la base : <pre class="brush:java"><br />import com.google.common.base.Throwables;<br />import org.h2.jdbcx.JdbcDataSource;<br /><br />import java.sql.Connection;<br />import java.sql.DriverManager;<br />import java.sql.SQLException;<br />import java.sql.Statement;<br /><br />public enum DatabaseManager {<br /><br />    INSTANCE;<br /><br />    public static final String TYPE_Q = "Q";<br />    public static final String DB_DRIVER = "org.h2.Driver";<br />    public static final String DB_USER = "sa";<br /><br />    private JdbcDataSource ds;<br /><br />    DatabaseManager() {<br />        try {<br />            Class.forName(DB_DRIVER);<br /><br />            boolean databaseExists = doesDatabaseExists();<br /><br />            ds = new JdbcDataSource();<br />            ds.setURL(DatabaseUtil.getUrl());<br />            ds.setUser(DB_USER);<br />            ds.setPassword(DB_USER);<br /><br />            if (!databaseExists) {<br />                createDatabase();<br />            }<br />        } catch (Exception exception) {<br />            Throwables.propagate(exception);<br />        }<br />    }<br /><br />    private static boolean doesDatabaseExists() {<br />        boolean databaseExists = false;<br />        try {<br />            String url = DatabaseUtil.getUrl() + ";IFEXISTS=TRUE";<br />            Connection connection = DriverManager.getConnection(url, DB_USER, DB_USER);<br />            connection.close();<br />            databaseExists = true;<br />        } catch (SQLException ignore) {<br />        }<br />        return databaseExists;<br />    }<br /><br />    public void createDatabase() throws SQLException {<br />        Connection conn = ds.getConnection();<br /><br />        Statement statementDrop = conn.createStatement();<br />        statementDrop.executeUpdate("DROP TABLE IF EXISTS LOG");<br /><br />        Statement statement = conn.createStatement();<br />        statement.executeUpdate("CREATE TABLE LOG (" +<br />                "HEURE TIMESTAMP," +<br />                "TYPE_LOG VARCHAR(10)," +<br />                "MESSAGE VARCHAR(500))");<br /><br />        statementDrop = conn.createStatement();<br />        statementDrop.executeUpdate("DROP TABLE IF EXISTS ENONCE");<br /><br />        statement = conn.createStatement();<br />        statement.executeUpdate("CREATE TABLE ENONCE (" +<br />                "ID INTEGER," +<br />                "TITLE VARCHAR(100)," +<br />                "ENONCE VARCHAR(4000))");<br /><br />        conn.close();<br />    }<br /><br />    private LogDao logDao;<br /><br />    public LogDao getLogDao() {<br />        if (logDao == null) {<br />            logDao = new LogDao(ds);<br />        }<br />        return logDao;<br />    }<br /><br />    private EnonceDao enonceDao;<br /><br />    public EnonceDao getEnonceDao() {<br />        if (enonceDao == null) {<br />            enonceDao = new EnonceDao(ds);<br />        }<br />        return enonceDao;<br />    }<br />}<br /></pre></p><p>Le but était de vous montrer que pour faire des trucs simples, il n'est pas toujours utile de sortir l'artillerie lourde avec du JPA ou autre... </p> <h2>Et pour les tests unitaires?</h2><p>Comme vous avez pu voir, les tests unitaires ne sont pas vraiment unitaire puisqu'ils testent l'application de bout en bout. Se pose du coup la question de la base de donnée qui ralentie les tests de manière inutile, heureusement h2 possède un mode mémoire qui rend la base très rapide et non persistante après les tests (ce qui permet de repartir à zéro à chaque fois). Pour passer d'un mode à l'autre, rien de sorcier : <pre class="brush:java">public static String getUrl() {<br />    if (test) {<br />        return "jdbc:h2:mem:codestory;DB_CLOSE_DELAY=-1";<br />    }<br />    return "jdbc:h2:./codestory";<br />}<br /></pre>Il ne faut pas oublier le "DB_CLOSE_DELAY=-1" qui permet de garder la base soit active tant que la jvm existe (ça évite d'avoir des problèmes de structures qui disparaissent d'un test à l'autre).</p><br /><br /><br /><p>À bientôt pour Scalaskel et la Calculette, puis pour le plus interessant : Jajascript et les performances.</p>
